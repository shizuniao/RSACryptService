
1.
在BouncyCastle实现RSA的PKCS1V1.5模式中，如果是公钥加密信息（forEncryption=true)，密钥长度为1024位，那么输出的密文块长度为128个字节，输入的明文块长度为127-10,即输入的明文块最大是117位，如果输入的明文块小于117位，比如输入的明文块长度为64位，那么会对这个明文块进行补位，在明文块前添加一位的0x02字节（代表公钥加密）然后后面的52位为随机的字节，在补位的最后一位，{即52（117-64-1），从零开始的},添加一位的字节0x00,在补位的后面添加实际的明文块。
这样做的目的就是使得明文块转化成与module差不多的大整数。

如果是私钥加密（forPrivateKey=true),密钥长度为1024位，那么输出 的密文块长度也是128字节，输入的明文块的长度为127-10，即输入的明文块最大是117位，如果输入的明文块小于117位，比如输入的明文块长度为64位，那么对这个明文块进行补位，在明文块前添加一位的0x01字节（代表私钥加密），然后在后面的52位为字节0xff，在最后一位｛即52（117-64-1）,从零开始)，添加一位的字节0x00，在补位的后面添加时间的明文块。


2.

C# 采用PKCS#1， Java采用PKCS#8
PKCS#1：定义RSA公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封[22]。
PKCS#8：描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等[27]。

3.

C#默认RSA只支持公钥加密，私钥解密。


5.


可以计算modulus的大小得出加解密的分组块大小

6.

想要研究微软对于RSA这块的源码可以用Reflector反编译微软的dll文件




